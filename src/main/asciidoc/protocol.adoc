= Programmation en Java : collections
François Roland <francois.roland@umons.ac.be>
2017-10-31
:icons: font
:experimental:
ifdef::backend-html5[]
:source-highlighter: highlightjs
endif::[]
ifdef::backend-pdf[]
:source-highlighter: coderay
:notitle:

[discrete]
= {doctitle}
endif::[]

Lors de cette séance de TP, nous verrons l'utilisation des collections Java permettant de gérer un ensemble de données.

== Notions

=== Structure de données

Le package `java.util` nous fournit deux hiérarchies particulièrement importantes pour la programmation.
La première permet de grouper des éléments relativement homogènes.
La seconde permet de créer des dictionnaires, c'est-à-dire un ensemble de valeurs auxquelles nous accédons à partir d'une clé.

[[collection-hierarchy]]
.Interfaces et classes principales de la hiérarchie de `Collection`
image::collection-hierarchy.svg[scaledwidth="90%", align="center"]

[[map-hierarchy]]
.Interfaces et classes principales de la hiérarchie de `Map`
image::map-hierarchy.svg[scaledwidth="80%", align="center"]

Chaque interface apporte ses propres fonctionnalités.
Chaque implémentation possède ses spécificités et ses propres contraintes.
En fonction de votre usage, vous choisirez l'interface appropriée.
Vous choisirez ensuite une implémentation de cette interface pour optimiser vos performances.

TIP: Je ne passerai pas en revue les spécifités des interfaces et classes du framework.
Ce serait bien trop long.
Je vous renvoie vers https://docs.oracle.com/javase/8/docs/technotes/guides/collections/reference.html[l'aperçu du framework collection], https://docs.oracle.com/javase/8/docs/technotes/guides/collections/overview.html[sa présentation] et https://docs.oracle.com/javase/8/docs/api/java/util/package-summary.html[la Javadoc du package `java.util`].
Vous trouverez notamment des indications sur les performances des différentes méthodes au début de la page de la Javadoc des classes d'implémentation.

Certaines map ou collections font des hypothèses sur les éléments qu'elles contiennent.
Les hypothèses les plus courantes portent sur :

* l'implémentation des méthodes `hashCode` et `equals`. Celles-ci sont utilisées par les collections et maps qui utilisent un algorithme de hachage.
* l'implémentation de l'interface `Comparable` ou d'un `Comparator`. Ceux-ci sont utilisés par les collections et maps qui trient leurs éléments.

[NOTE]
====
L'implémentation par défaut des méthodes `hashCode` et `equals` se base sur l'adresse mémoire de l'objet.
Deux instances différentes seront donc toujours différentes, même si leur contenu est unique.
Le contrat des ces deux méthodes est plus compliqué que vous pourriez le croire.
Référez-vous à https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html[la Javadoc de la classe `Object`] pour connaître leur spécification.
Les méthodes statiques `equals(Object valueA, Object valueB)` et `hash(Object... values)` vous aideront à implémenter correctement ces méthodes.
La plupart des IDE permettent de les générer facilement en sélectionnant les champs de votre classe.

[source,java]
.Example d'implémentation des méthodes `equals` et `hashCode`
----
@Override
public boolean equals(Object o) {
    if (this == o) return true;
    if (o == null || getClass() != o.getClass()) return false;
    Person person = (Person) o;
    return Objects.equals(firstName, person.firstName) &&
        Objects.equals(lastName, person.lastName);
}

@Override
public int hashCode() {
    return Objects.hash(firstName, lastName);
}
----

====

WARNING: Il est dangereux de baser les méthodes `equals` et `hashCode` de la même classe sur des champs différents.
Les classes du framework collections font l'hypothèse que ces méthodes se comportent de manière consistante.
Cette remarque vaut aussi si vous implémentez l'une de ces méthodes mais pas l'autre.

.Méthodes et interfaces utilisées dans le framework
image::object-and-comparison.svg[scaledwidth="60%", align="center"]

=== Itérations

En plus de l'interface Collection, les classes List et Set étendent l'interface Iterable définissant une méthode iterator.
Cette dernière devra retourner un objet implémentant l'interface Iterator.
Cette interface présente les méthodes hasNext, next et remove qui permettent de se déplacer au sein de la structure de données.
Des sous-interfaces de Iterator (e.g. ListIterator) permettent d'ajouter des fonctionnalités suivant le type de structure de données.
Par exemple, le parcours d'une liste nommée liste1 peut se faire de la manière suivante :
ListIterator it = liste1.listIterator();
while(it.hasNext())
{
Object obj = it.next();
}

NOTE: les Maps n'implémentant pas l'interface Iterable, ils ne permettent pas d'être parcourus à l'aide d'un itérateur.
Toutefois, il sera possible de le faire en convertissant chaque Map, à l'aide de la méthode values, en une Collection équivalente (qui, elle, implémente l'interface Iterable).

=== Les méthodes de la classe Collections

La classe Collections définit des méthodes statiques qui seront utilisées pour réaliser différents traitements sur les collections.
Certaines de ces méthodes ne s'appliquent que sur des listes ; c'est le cas de:

* sort : trie les éléments de la liste dans l'ordre naturel ; il est possible de spécifier un objet Comparator permettant « d'expliquer » à sort comment trier des éléments;
* shuffle : ordonne de manière aléatoire les éléments de la liste;
* reverse : inverse l'ordre des éléments de la liste;
* fill : réinitalise la liste avec une valeur définie;
* copy : copie une liste dans une autre.

Remarquons que le tri d'éléments est naturel pour des valeurs numériques mais ne l'est pas forcément pour des objets plus complexes.
En effet, la fonction de tri doit savoir comment comparer deux objets en vue de les classer.
Dans ce but, on souhaitera implémenter l'interface Comparable<T> définissant une méthode compareTo.
Cette dernière retournera 1, 0 ou 1 suivant que l'argument passé à la méthode compareTo est « plus petit », « équivalent » ou « plus grand », au sens de l'ordonnancement que l'on souhaite introduire.

=== Généricité

Il est parfois nécessaire de gérer des classes ou des méthodes pour lesquelles on ne connaît pas à l'avance le type traité.
On peut alors spécifier un type indéfini dans la déclaration de la classe, comme dans l'exemple suivant:
public class Pile<E>
Le type E peut ensuite être utilisé au sein de la classe qui est appelée classe générique.

Il est également possible de définir des méthodes génériques; on peut alors soit utiliser le caractère ? ou faire précéder le type de retour de la méthode par le type générique:
public static void method(? el) public static <E> void method(E el)
On peut également obliger le type E à être une sousclasse d'une classe déterminée ou à implémenter une interface déterminée:
public static <E extends Pile> void method(E el)

== Exercices

=== Exercice 1

On souhaite gérer un ensemble d'étudiants. Chaque étudiant sera défini par une classe Etudiant et devra présenter les informations suivantes:

* un matricule;
* un nom;
* une liste de Cotes (de taille indéfinie).

Une classe Cote permettra de contenir pour chaque cours, l'intitulé du cours ainsi que la cote obtenue.
Les cotes de chaque étudiant seront stockées dans une ArrayList.
Une méthode addCote permettant d'ajouter une cote à l'étudiant sera définie.

=== Exercice 2

On souhaite mettre en place une classe capable de réaliser des statistiques sur une collection d'objets, comme par exemple, des Etudiants, des Cotes, ...
Cette classe, qui sera nommée Stats, pourra ainsi calculer le maximum, le minimum et la moyenne d'une collection d'objets.
Toutes les classes qui peuvent faire l'objet de statistiques implémenteront une interface Statisticable, qui est décrite comme suit :
public interface Statisticable {
public abstract float getValue();
}
Tout objet « statisticable » doit donc avoir une certaine valeur; pour un Etudiant, on choisit de prendre la moyenne de ses cotes comme valeur de l'Etudiant.
La classe Stats sera ensuite utilisée et donnera pour :

* chaque étudiant:
** sa moyenne;
** sa meilleure cote;
** sa moins bonne cote;
* chaque groupe d'étudiants:
** la moyenne du groupe;
** le meilleur étudiant;
** le moins bon étudiant.

=== Exercice 3

On souhaite pouvoir classer la liste d'étudiants suivant le matricule.
Pour ce faire, on implémentera l'interface Comparable dans la classe Etudiant.
La méthode compareTo devra donc être définie dans la classe Etudiant.

NOTE: il sera utile de se référer à la documentation en ligne pour implémenter correctement l'interface Comparable.
Une fois cela réalisé, on triera la liste d'étudiants à l'aide de la méthode Collections.sort.

=== Exercice 4

On souhaite également pouvoir trier la liste d'étudiants par moyenne et par nom.
Dans ce but, deux nouvelles classes (CompareMoyenne et CompareNom) seront créées et implémenteront l'interface Comparator.
Ces classes devront donc chacune définir une méthode compare prenant comme arguments les deux objets à comparer et réalisant un traitement similaire à celui de compareTo dans l'exercice précédent.

[bibliography]
== Références

* Deitel, H. M., & Deitel, P. J. (2002). _Java : comment programmer (4th ed.)_. Les éditions Reynald Goulet INC.
* Deitel, P. J., & Deitel, H. M. (2007). _Java: how to program (7th ed.)_. Les éditions Reynald Goulet INC.
* Evans, E. (2003). _Domain-driven design: tackling complexity in the heart of software (1st ed.)_. Addison-Wesley Professional.
* Manneback, P., & Frémal, S. (2014-2015). _Travaux pratiques de Méthodologie et Langage de Programmation_. UMons.
* Manneback, P. (2005-2006). _Méthodologie et Langages de Programmation_. UMons.
* _Java Platform Standard Edition 8 Documentation_. Récupéré de https://docs.oracle.com/javase/8/docs/
